# DP解法
## 原理
最大值问题可以转换为DP问题，因要求连续子串，迭代函数考虑f(i)以右节点结尾i作为条件
```
f(i) = max(f(i - 1) + nums[i], nums[i])
```
## 复杂度分析
时间复杂度：遍历一次数组即可完成搜索计算，因此O(N)
空间复杂度：逐个缓存f(i)，因此O(N)

## 优化
缓存所有f(i)其实比较浪费，只需要缓存f(i-1)即可，空间复杂度为O(1)

# 分治解法
## 原理
采用线段树进行分治计算和缓存，先遍历数据建立线段树，再通过树搜索查找对应值。
线段树虽然麻烦，但是因为缓存可以多次使用且可以指定任意子数组进行求值，对于多次查询场景非常好用
线段树的限制是子序列可求和，即父节点的结果可以通过左右子节点的结果进行“求和”计算得出

## 复杂度分析
时间复杂度：遍历一次数组构建线段树为O(N)；搜索深度为O(logN)，复杂度为O(logN)；综上为O(N)
空间复杂度：存储线段树耗费O(logN）空间
