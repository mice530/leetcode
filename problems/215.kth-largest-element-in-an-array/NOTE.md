# 题目
在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

示例 1:
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5

示例 2:
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4

说明:
你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

# 原理
## 快速选择（基于快排原理）
使用快排方案，原地快速分区互换，左侧大等于pivot，右侧小于pivot，然后根据游标位置确定k位是在pivot的左侧还是右侧，然后递归继续计算，直到找到pivot所在位置就是第k位。其实该方案就是快排 + 剪枝（排除掉不需要排序的空间，只关注k位所在区域）
实现时采用了循环方式替换递归，可以解决大数据量下的调用栈过多问题。

## 堆排序
采用堆排序，排序时只取前K位，即先建大顶堆，然后执行K此删除顶部元素，第K个即所求元素


# 复杂度分析
## 快速选择
时间O(N)：平均情况下遍历次数为 N + 1/2N + ... + 1/2^(logN-1) * N + 1 = 2N - 1；因为pivot选择采用中位方式，最差情况等同平均情况；因此时间复杂度O(N)
空间O(1)：因为是原地排序，无额外空间开销，空间复杂度为O(1)

## 堆排序
时间O(N)：建堆成本为1 * h + 2 * (h-1) + ... + 2^(h-k) * (h-k) + 2^(h-1) * 2 = 2^h - 2 = n - 2，即O(N)；排序成本约为 log(n-1) + log(n-2) + ... log(n-k) ~= k * logN；因此时间复杂度为O(N + K * logN) ~= O(N * logN)
空间O(1)：因为是原地排序，无额外空间开销，空间复杂度为O(1)
